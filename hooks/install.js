#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const chalk = require('chalk');

/**
 * Installs git hooks for the current project
 */
function installHooks() {
  console.log(chalk.blue('\nüîß Installing QA test hooks...\n'));
  
  // Check if we're in a git repository
  const gitDir = path.join(process.cwd(), '.git');
  if (!fs.existsSync(gitDir)) {
    console.log(chalk.yellow('‚ö†Ô∏è  No .git directory found. Skipping hook installation.'));
    console.log(chalk.gray('   This is normal if installing globally or in CI/CD environment.\n'));
    return;
  }
  
  const hooksDir = path.join(gitDir, 'hooks');
  
  // Ensure hooks directory exists
  if (!fs.existsSync(hooksDir)) {
    fs.mkdirSync(hooksDir, { recursive: true });
  }
  
  // Detect project name for the hook
  let projectName = 'unknown';
  const packagePath = path.join(process.cwd(), 'package.json');
  
  if (fs.existsSync(packagePath)) {
    try {
      const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
      projectName = pkg.name || 'unknown';
    } catch (error) {
      // Ignore error
    }
  }
  
  // Pre-commit hook content
  const preCommitHook = `#!/bin/sh
# Auto-generated by @am-bateriku/qa-scripts
# This hook runs QA tests before allowing a commit

set -e

echo "üß™ Running QA tests before commit..."

# Check if qa-scripts is installed
if ! npm list @am-bateriku/qa-scripts >/dev/null 2>&1; then
  echo "‚ö†Ô∏è  @am-bateriku/qa-scripts not found. Installing..."
  npm install --save-dev @am-bateriku/qa-scripts
fi

# Update to latest version (optional - comment out if you want to control versions)
# npm update @am-bateriku/qa-scripts

# Run tests for this project
npm run qa:test:local

if [ $? -ne 0 ]; then
  echo ""
  echo "‚ùå QA tests failed! Please fix the issues before committing."
  echo "   To run tests manually: npm run qa:test:local"
  echo "   To run in headed mode: npm run qa:test:headed"
  echo ""
  exit 1
fi

echo "‚úÖ All QA tests passed!"
exit 0
`;
  
  // Pre-push hook content (optional, more comprehensive)
  const prePushHook = `#!/bin/sh
# Auto-generated by @am-bateriku/qa-scripts
# This hook runs comprehensive QA tests before pushing

set -e

echo "üß™ Running comprehensive QA tests before push..."

# Update qa-scripts to latest version
npm update @am-bateriku/qa-scripts

# Run full test suite
npm run qa:test:staging

if [ $? -ne 0 ]; then
  echo ""
  echo "‚ùå QA tests failed! Please fix the issues before pushing."
  echo "   To run tests: npm run qa:test:staging"
  echo ""
  exit 1
fi

echo "‚úÖ All QA tests passed!"
exit 0
`;
  
  // Install pre-commit hook
  const preCommitPath = path.join(hooksDir, 'pre-commit');
  const existingPreCommit = fs.existsSync(preCommitPath);
  
  if (existingPreCommit) {
    // Backup existing hook
    const backupPath = `${preCommitPath}.backup.${Date.now()}`;
    fs.renameSync(preCommitPath, backupPath);
    console.log(chalk.yellow(`‚ö†Ô∏è  Existing pre-commit hook backed up to: ${path.basename(backupPath)}`));
  }
  
  fs.writeFileSync(preCommitPath, preCommitHook);
  fs.chmodSync(preCommitPath, '755');
  console.log(chalk.green('‚úÖ Pre-commit hook installed'));
  
  // Optionally install pre-push hook (commented out by default)
  // const prePushPath = path.join(hooksDir, 'pre-push');
  // fs.writeFileSync(prePushPath, prePushHook);
  // fs.chmodSync(prePushPath, '755');
  // console.log(chalk.green('‚úÖ Pre-push hook installed'));
  
  // Add npm scripts if they don't exist
  updatePackageScripts();
  
  console.log(chalk.green.bold('\n‚úÖ QA test hooks installed successfully!\n'));
  console.log(chalk.gray('   The following npm scripts are now available:'));
  console.log(chalk.cyan('   ‚Ä¢ npm run qa:test         - Run tests for this project'));
  console.log(chalk.cyan('   ‚Ä¢ npm run qa:test:local   - Run tests with local environment'));
  console.log(chalk.cyan('   ‚Ä¢ npm run qa:test:staging - Run tests with staging environment'));
  console.log(chalk.cyan('   ‚Ä¢ npm run qa:test:headed  - Run tests in headed mode (visible browser)'));
  console.log(chalk.cyan('   ‚Ä¢ npm run qa:update       - Update qa-scripts to latest version\n'));
}

/**
 * Updates package.json with QA test scripts
 */
function updatePackageScripts() {
  const packagePath = path.join(process.cwd(), 'package.json');
  
  if (!fs.existsSync(packagePath)) {
    console.log(chalk.yellow('‚ö†Ô∏è  No package.json found. Skipping script installation.'));
    return;
  }
  
  try {
    const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
    
    // Initialize scripts if not present
    if (!pkg.scripts) {
      pkg.scripts = {};
    }
    
    // Add QA scripts if they don't exist
    const qaScripts = {
      'qa:test': 'qa-test',
      'qa:test:local': 'qa-test --env local',
      'qa:test:staging': 'qa-test --env staging',
      'qa:test:production': 'qa-test --env production',
      'qa:test:headed': 'qa-test --headed',
      'qa:test:debug': 'qa-test --headed --debug',
      'qa:update': 'npm update @am-bateriku/qa-scripts',
      'qa:update:latest': 'npm install @am-bateriku/qa-scripts@latest',
    };
    
    let scriptsAdded = false;
    
    Object.entries(qaScripts).forEach(([name, command]) => {
      if (!pkg.scripts[name]) {
        pkg.scripts[name] = command;
        scriptsAdded = true;
      }
    });
    
    if (scriptsAdded) {
      // Write updated package.json
      fs.writeFileSync(packagePath, JSON.stringify(pkg, null, 2) + '\n');
      console.log(chalk.green('‚úÖ QA test scripts added to package.json'));
    } else {
      console.log(chalk.gray('‚ÑπÔ∏è  QA test scripts already present in package.json'));
    }
  } catch (error) {
    console.error(chalk.red('‚ùå Failed to update package.json:'), error.message);
  }
}

// Run installation if called directly
if (require.main === module) {
  installHooks();
}

module.exports = { installHooks };